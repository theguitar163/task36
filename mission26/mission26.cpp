// 任务：迷宫求解。
// 该任务包括两点要求：
// (1) 创建一个随机的迷宫，要求该迷宫有且仅有一条从起点通往终点的路线，同时，任何位置都不存在环路。
// (2) 自动求解从起点通往终点的路线。

// 迷宫生成算法：递归分割算法（Recursive division）
// 可以用递归分割法创建迷宫，算法的工作原理如下：
// 1.开始创建迷宫，使整个空间没有壁，我们称之为“室”。
// 2.在随机位置生成壁将室分割为两个子室，并在壁上随机开孔，使子室联通。
// 3.重复步骤2，直到所有子室全部不可分割（即子室某一个维度等于1）。
// 例如，在矩形迷宫中，在任意点建立彼此垂直的两个壁。 这两个壁将大腔室分成由四个壁分开的四个较小腔室。 
// 随机选择四个墙壁中的三个，并在三个墙壁的随机点处打开一个单元格的孔。 
// 继续以这种方式递归，直到每个室在两个方向中的任一个方向上具有一个单元的宽度。
// 因为没有起点的概念，所以没有起点位置参数，取而代之的是最小面积参数，
// 这个参数是我用来制造“房间”的，当子空间面积小于这个值就会强制停止分割，
// 这样就可以造出随机的房间，并在一定程度上避免该算法过于弱智的“一条长长的死胡同”问题。

// 迷宫生成算法：递归回溯（Recursive backtracker）

// 迷宫寻路算法：深度优先遍历
// 迷宫寻路算法：广度优先遍历
// 迷宫寻路算法：A - Star
#include <stdio.h>
#include <conio.h>
#include <easyx.h>

#include "maze.h"
#include "draw_maze.h"

int main()
{
    srand(GetTickCount());	//随机数种子
    initgraph(MAX_COL * CELL_SIZE, MAX_ROW * CELL_SIZE);

    BeginBatchDraw();

    createMaze_prim();
    _getch();

    createMaze_deepsearch();
    
    EndBatchDraw();
    _getch();
}
